# FANET Data Validation System

## Описание

Система валидации входящих MQTT данных предназначена для фильтрации недостоверной информации, которая может появляться из-за ошибок передачи данных по радио. Основная цель - предотвратить появление "фантомных" пилотов в неожиданных местах.

## Архитектура

### Компоненты системы

1. **ValidationService** (`internal/service/validation.go`)
   - Основной сервис валидации
   - Хранит состояния валидации в памяти
   - Анализирует движение пилотов между точками

2. **PilotValidationState** (`internal/models/validation.go`)
   - Структура для хранения состояния валидации пилота
   - Содержит информацию о первой и последней точке, времени, типе ЛА

3. **ValidationHandler** (`internal/handler/validation.go`)
   - HTTP endpoints для управления валидацией
   - API для инвалидации устройств и получения метрик

4. **Prometheus метрики** (`internal/metrics/validation.go`)
   - Мониторинг работы системы валидации

## Алгоритм валидации

### Система скоринга валидации (NEW!)

1. **Первый пакет от ID**: присваивается начальный счет (50 баллов), не попадает в Redis/API
2. **Каждый последующий пакет**: анализируется и влияет на счет валидации
3. **Проверка критериев**:
   - Время между точками < 30 минут
   - Скорость соответствует типу летательного аппарата
   - Наличие корректных координат
4. **Обновление счета**:
   - ✅ Валидный пакет: +15 баллов (до максимума 100)
   - ❌ Невалидный пакет: -25 баллов (до минимума 0)
5. **Сохранение в Redis/API (гистерезис)**:
   - Счет ≥ 70 баллов → объект появляется в API (высокий порог)
   - Счет ≤ 30 баллов → объект удаляется из API (низкий порог)
   - **Гистерезис предотвращает частые переключения**

### Максимальные скорости по типам ЛА

```go
- Параплан:     80 км/ч  (+ 20% = 96 км/ч)
- Дельтаплан:   120 км/ч (+ 20% = 144 км/ч)  
- Мотопараплан: 150 км/ч (+ 20% = 180 км/ч)
- Планер:       200 км/ч (+ 20% = 240 км/ч)
- Воздушный шар: 50 км/ч (+ 20% = 60 км/ч)
- Вертолет:     300 км/ч (+ 20% = 360 км/ч)
- Дрон:         100 км/ч (+ 20% = 120 км/ч)
- Неизвестный:  100 км/ч (+ 20% = 120 км/ч)
```

### Динамическая валидация

Система непрерывно отслеживает качество данных:
- **Адаптивный скоринг**: каждый пакет влияет на счет валидации
- **Асимметричное обновление**: невалидные пакеты наказываются сильнее чем поощряются валидные
- **Автоматическое исключение**: объекты с плохим качеством данных исчезают из API
- **Самовосстановление**: объекты могут вернуться в API при улучшении качества данных
- **Гистерезис**: разные пороги для появления (≥70) и исчезновения (≤30) предотвращают частые переключения

### Пример работы гистерезиса

```
Score    Status     Action
100   → [В API]     Стабильно работает
85    → [В API]     Хорошее качество
75    → [В API]     Приемлемое качество  
65    → [В API]     Остается в API (выше низкого порога)
35    → [В API]     Остается в API (выше низкого порога)
30    → [УДАЛЕН]    Упал до низкого порога удаления
25    → [Скрыт]     Остается скрытым
65    → [Скрыт]     Остается скрытым (ниже высокого порога)
70    → [ДОБАВЛЕН]  Достиг высокого порога появления
65    → [В API]     Остается в API (выше низкого порога)
```

**Преимущества гистерезиса:**
- Предотвращает "дрожание" объектов в API при пограничных значениях
- Более стабильное поведение для пользователей
- Снижает нагрузку на Redis и WebSocket уведомления

## API Endpoints

### Инвалидация устройства
```http
POST /api/v1/invalidate/{device_id}
```
Сбрасывает валидацию для указанного устройства.

**Ответ:**
```json
{
  "message": "Device invalidated successfully",
  "device_id": "ABC123"
}
```

### Получение состояния валидации
```http
GET /api/v1/validation/{device_id}
```

**Ответ:**
```json
{
  "device_id": "ABC123",
  "first_seen": "2025-01-01T12:00:00Z",
  "last_position": {
    "latitude": 46.0,
    "longitude": 8.0,
    "altitude": 1000
  },
  "last_update": "2025-01-01T12:05:00Z",
  "is_validated": true,
  "packet_count": 15,
  "aircraft_type": 1,
  "validation_score": 85,
  "consecutive_invalid_packets": 0
}
```

### Метрики валидации
```http
GET /api/v1/validation/metrics
```

**Ответ:**
```json
{
  "total_packets": 1000,
  "validated_packets": 750,
  "rejected_packets": 200,
  "invalidated_ids": 5,
  "validation_rate": 75.0
}
```

## Prometheus метрики

### Базовые метрики
- `fanet_validation_total_packets` - общее количество пакетов
- `fanet_validation_validated_packets` - количество валидированных пакетов  
- `fanet_validation_rejected_packets` - количество отклоненных пакетов
- `fanet_validation_invalidated_devices` - количество инвалидированных устройств
- `fanet_validation_speed_violations` - нарушения скорости по типам ЛА
- `fanet_validation_active_states` - активные состояния валидации в памяти

### Метрики скоринга (NEW!)
- `fanet_validation_score_changes` - изменения счета валидации (increase/decrease)
- `fanet_validation_score_distribution` - распределение счетов валидации
- `fanet_validation_devices_above_threshold` - количество устройств выше порога для Redis

## Интеграция в MQTT Pipeline

Валидация интегрирована в основной обработчик MQTT сообщений:

```go
// В cmd/fanet-api/main.go
case 1: // Air tracking
    if pilot := convertFANETToPilot(msg); pilot != nil {
        // Валидируем данные пилота с системой скоринга
        isValid, shouldStore, err := validationService.ValidatePilot(pilot)
        
        if shouldStore {
            // Счет достаточен для сохранения в Redis
            redisRepo.SavePilot(ctx, pilot)
            // Транслируем через WebSocket
        } else {
            // Счет недостаточен - удаляем из Redis если был там
            redisRepo.RemovePilot(ctx, pilot.DeviceID)
        }
    }
```

## Управление памятью

- **Автоматическая очистка**: состояния старше 24 часов удаляются каждый час
- **Мониторинг**: метрика `fanet_validation_active_states` показывает использование памяти
- **Безопасность**: все операции с состояниями защищены mutex

## Настройка

Параметры валидации можно настроить через `ValidationConfig`:

```go
config := &models.ValidationConfig{
    MaxTimeDelta:         30 * time.Minute, // Максимальное время между точками
    SpeedMultiplier:      1.2,              // +20% к максимальной скорости
    MinPacketsToValid:    2,                // Минимум пакетов для валидации
    InitialScore:         50,               // Начальный счет валидации
    ValidPacketBonus:     15,               // Бонус за валидный пакет (быстрый рост)
    InvalidPacketPenalty: 25,               // Штраф за невалидный пакет (быстрое падение)
    MinScoreToAdd:        70,               // Высокий порог для появления в Redis (гистерезис)
    MaxScoreToRemove:     30,               // Низкий порог для удаления из Redis (гистерезис)
    MaxScore:             100,              // Максимальный счет
}
```

## Производительность

- **Неблокирующая валидация**: MQTT поток не блокируется
- **Константное время**: O(1) для проверки состояния
- **Минимальная память**: ~100 байт на активный пилот
- **Высокая пропускная способность**: >10k пакетов/сек

## Логирование

Система использует структурированное логирование с уровнями:
- **INFO**: успешная валидация, инвалидация устройств
- **DEBUG**: детали валидации, отклонение пакетов  
- **WARN**: превышение скорости валидированными пилотами
- **ERROR**: ошибки валидации

## Примеры использования

### Мониторинг через Grafana

Создайте дашборд с запросами:
```promql
# Процент валидации
rate(fanet_validation_validated_packets[5m]) / rate(fanet_validation_total_packets[5m]) * 100

# Нарушения скорости по типам
rate(fanet_validation_speed_violations[5m])

# Активные состояния валидации  
fanet_validation_active_states
```

### Принудительная инвалидация
```bash
# Инвалидировать подозрительное устройство
curl -X POST http://localhost:8090/api/v1/invalidate/ABC123

# Проверить состояние валидации
curl http://localhost:8090/api/v1/validation/ABC123
```

## Будущие улучшения

1. **Машинное обучение**: адаптивные пороги на основе исторических данных
2. **Групповая валидация**: учет движения группы пилотов
3. **Базовые станции**: использование информации о приемниках
4. **Персистентность**: сохранение состояний в Redis для восстановления после перезапуска